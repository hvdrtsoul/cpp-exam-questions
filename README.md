# ООП   

## Вопросы на сессию

### 1. Что такое объект?

Объявление класса определяет новый тип, который связывает код и данные между собой. Таким образом, класс является абстракцией, а объект - её физическим воплощением.

***Объект*** или ***экземпляр класса*** – в узком смысле слова – это адресуемая одним адресом область памяти для хранения значений всех полей.

**Объект** – ****то, что может быть индивидуально описано и рассмотрено.

### 2. Определение системы и три примера систем.

Система — это совокупность материальных или информационных объектов, обладающая определенной целостностью.

**Система** – множество взаимосвязанных и взаимодействующих объектов для решения одной или множества задач (достижения одной или множества целей).

Состав системы — это совокупность входящих в нее частей (элементов).

Рассматривая компьютер как систему, можно выделить следующие составляющие его части: процессор, память, устройства ввода, устройства вывода. Но, в свою очередь, процессор тоже является системой (подсистемой), в состав которой входят более низкоуровневые элементы - устройства вычислительной техники.

Университет - тоже система. Система, реализующая обучение определенным профессиям и навыкам. В свою очередь, университет - иерархия, состоящая из большого количества подсистем.

### 3. Жизненный цикл объекта.

Жизненный цикл объекта насчитывает три пункта:

- создание — выделение и инициализация памяти для хранения значений полей объекта
- объект существует в памяти (может быть как доступен, так и не доступен в коде - функционирует или нет)
- уничтожение — освобождение памяти, используемой для хранения значений полей объекта

### 4. Взаимодействие объектов. Три примера взаимодействия объектов.

Обычно при написании объектно-ориентированных программ мы рассматриваем не рассматриваем объекты изолированно, а используем именно взаимодействие объектов, поскольку это предоставляет нам больше возможностей.

Совместное использование методов различных объектов — показатель взаимодействия объектов.

Примеры:

1. Объект группы и объект студента — какие-либо свойства объекта студента или сам объект студента могут стать аргументом, с которым вызовется метод группы, например, записывающий успеваемость или посещаемость студента. Или же выводящий его рейтинг в группе.

Если в группе есть геттер “средняя оценка”, то студент, получив доступ к таким данным (вызвав метод объекта группы) может получить информацию, насколько хороша его успеваемость по сравнению с одногруппниками. Таким образом - связь двунаправленная.
2. Объект зоопарка и объект зверя.
3. Объект преподавателя и объект студента. - не иерархический прием по сравнению с двумя предыдущими.

### 5. Класс. Назначение и синтаксис описания.

Объявление класса определяет новый тип, который связывает код и данные между собой. Таким образом, класс является абстракцией, а объект - её физическим воплощением.

```cpp
// Myclass.h
class Myclass {
  double turn;
public:
	double period;
  void rotate(double deg);
};

// Myclass.cpp
void Myclass::rotate(double deg)
{
  turn = (turn + deg) % 360;
}
```

### 6. Жизненный цикл виртуального объекта и его реализация на языке С++.

Жизненный цикл объекта насчитывает три пункта:

- создание — выделение и инициализация памяти для хранения значений полей объекта
- объект существует в памяти (может быть как доступен, так и не доступен в коде - функционирует или нет)
- уничтожение — освобождение памяти, используемой для хранения значений полей объекта

Объект реализуется путем создания экземпляра класса или структуры — описания абстрактного типа — объекта.

### 7. Архитектура системы. Иерархия объектов.

Архитектура системы так или иначе строится путем создания иерархии объектов и взаимодействия между объектами.

**Иерархическая структура системы**

![Untitled](%D0%9E%D0%9E%D0%9F%20dced1/Untitled.png)

### 8. Программа – система.

Любая программа, написаная в объектно-ориентированном стиле является системой.

Схема приложения

![Untitled](%D0%9E%D0%9E%D0%9F%20dced1/Untitled%201.png)

### 9. Наследование. Реализация наследования на языке С++.

Наследование - возможность создания новых классов на основе уже существующих.

### 10. Управление доступом при наследовании.

Наследовать можно с идентификаторами:

- `private` (по умолчанию) — все унаследованные `public` и `protected` свойства и методы становятся `private` внутри дочернего класса.
- `protected` — все унаследованные `public` свойства и методы становятся `protected` внутри дочернего класса.
- `public` — наследуемые свойства и методы сохраняют свои модификаторы доступа.

```cpp
class Animal {
public:
  virtual void makeSound() const;
};

class Dog : public Animal {
public:
  void makeSound() const;
};
```

При множественном наследовании идентификатор доступа указывается для каждого класса

```cpp
class Base1;
class Base2;

class Derived : public Base1, protected Base2;
```

Вызов конструктора дочернего класса в конструкторе родительского класса

```cpp
class Base
{
protected:
    int i;
public:
    Base(int x) { i = x; std::cout << "Создание объекта класса Base\n" }
    ~Base() { std::cout << "Уничтожение объекта класса Base\n" }
}

class Derived: public Base
{
protected:
    int j;
public:
    Base(int x, int y): Base(y)
    { j = x; std::cout << "Создание объекта класса Base\n" }
    ~Base() { std::cout << "Уничтожение объекта класса Base\n" }
}
```

[Подробнее про модификаторы доступа при наследовании](https://www.programiz.com/cpp-programming/public-protected-private-inheritance)

### 11. Инкапсуляция.

Инкапсуляция - способ спрятать часть состояния и поведения объектов и отдавать лишь ограниченный интерфейс для взаимодействия с ним.

На практике это означает использование модификаторов private и public.

Также инкапсулированным называется объект с публичными свойствами и методами, которые рассматриваются неотделимыми друг от друга. (не создаем переменную счетчика локально и передаем ее по ссылке в функции, а создаем объект, методы которого есть эти функции). 

### 12. Полиморфизм.

Полиморфизм - способность программы обнаруживать настоящий класс объекта и вызывать его реализацию даже когда тип этого объекта неизвестен в текущем контексте.

C++ реализует как *статический*, так и *динамический полиморфизм*.

*Статический полиморфизм* достигается с помощью перегрузки функций и операторов.

*Динамический полиморфизм* реализуется на основе наследования и виртуальных функций.

В основу объектно-ориентированного программирования положен принцип “один интерфейс, несколько методов’’. Он позволяет определять базовый класс операций с единообразным интерфейсом, а их конкретизацию предоставлять производным классам.

```cpp
#include <iostream>

class Animal {
public:
  virtual void makeSound() const;
};

class Dog : public Animal {
public:
  void makeSound() const;
};

void Animal::makeSound() const
{
  std::cout << "Moo" << std::endl;
}

void Dog::makeSound() const
{
  std::cout << "Woof" << std::endl;
}

void urge_beast_to_make_sound(const Animal& beast)
{
	beast.makeSound();
}

int main()
{
	Animal animal;
	Dog dog;

	urge_beast_to_make_sound(dog); // "Woof"

	return 0;
}
```

### 13. Управление доступом к элементам класса.

Модификаторы private и protected. (public по умолчанию)

По умолчанию элементы `struct` — `public`, элементы `class` — `private`.

### 14. Конструктор и деструктор объекта.

*Конструктор* — функция, вызываемая в момент создания объекта предназначенная для его инициализации (установки в требуемое состояния, путем присваивания значений полям и вызова методов), возвращающая экземпляр класса.

**Конструкторы можно перегружать.**

*Деструктор* — функция, вызываемая в момент уничтожения объекта или вызова оператора `delete`, в которой реализуется освобождение памяти, которую объект занимал в процессе своего жизненного цикла.

Порядок вызова конструкторов и деструкторов при наследовании классов:

![Untitled](%D0%9E%D0%9E%D0%9F%20dced1/Untitled%202.png)

### 15. Параметризированные конструкторы.

Конструкторам можно передавать аргументы, предназначенные для инициализа­ции объекта.

```cpp
class MyClass
{
	int capacity;
public:
	MyClass(int _capacity);
}

MyClass::MyClass(int _capacity)
{
	capacity = _capacity;
}
```

### 16. Конструктор копирования.

Одним из важнейших видов перегруженного конструктора является *конструктор
копирования*. Он позволяет предотвратить проблемы, которые могут возникнуть при присваивании одного объекта другому.

Рассмотрим проблему, для решения которой необходим конструктор копирования. По умолчанию, если один объект инициализируется другим, создается побитовая копия при­сваиваемого объекта. Иначе говоря, инициализируемому объекту присваивается его иден­тичная копия. Иногда побитовая копия оказывается неприемлемой. Обычно это происхо­дит, когда объект выделяет динамическую память. Например, допустим, что класс `MyClass` выделяет динамическую память для каждого создаваемого объекта, а объект **`А`**
является его экземпляром. Это значит, что объект `A` ****уже выделил для себя динамическую
память. Теперь предположим, что объект `A` ****инициализирует объект `B`:

```cpp
MyClass B = A;
```

Если при этом создается побитовая копия объекта `A`, то объект в будет точной копией объекта `A`. Следовательно, объект в также будет ссылаться на область памяти, выде­ленную объектом `A`, не выделяя свой собственный участок. Очевидно, это совсем не то, к чему мы стремились. Например, если класс `MyClass` содержит деструктор, осво­бождающий память, то при уничтожении объектов `A` и `B` одна и та же область памяти будет освобождаться дважды!

Эта проблема может возникнуть еще в двух ситуациях. Во-первых, когда функции передается копия параметра, и, во-вторых, когда создается временный объект, воз­ вращаемый функцией. Напомним, что функция создает временный объект, в котором хранится возвращаемое ею значение.

Для решения этих проблем предназначен конструктор копирования, который не использует побитовое копирование. Наиболее часто применяется следующая его форма:

```cpp
MyClass::MyClass(const MyClass& mc) {}
```

В этой реализации массива необходим конструктор копирования.

```cpp
class Array
{
    int *p;
    int size;
public:
    Array(int);
    Array(const Array&);
    int& operator[](size_t);
		void operator()();
    std::ostream& operator<<(std::ostream&);
    ~Array();
};

Array::Array(int sz)
{
    p = new int[sz];

    size = sz;
}

Array::Array(const Array& arr)
{
    p = new int[arr.size];

    for (int i = 0; i < size; i++)
        p[i] = arr.p[i];
}

int& Array::operator[](size_t i)
{
    return p[i];
}

void Array::operator()()
{
    std::cout << "Called an array!" << std::endl;
}

Array::~Array()
{
    delete[] p;
}

int main()
{
    Array arr1(10);

    for (int i = 1; i <= 10; i++)
        arr1[i - 1] = i * i;
    
    for (int i = 0; i < 10; i++)
        std::cout << arr1[i] << ((i != 10) ? " " : "");
    std::cout << std::endl;

    Array arr2 = arr1;

    for (int i = 0; i < 10; i++)
        arr1[i] = (i + 11) * (i + 11);
    
    for (int i = 0; i < 10; i++)
        std::cout << arr1[i] << ((i != 10) ? " " : "");
    std::cout << std::endl;

    for (int i = 0; i < 10; i++)
        std::cout << arr2[i] << ((i != 10) ? " " : "");
    std::cout << std::endl;
    
    return 0;
// 1 4 9 16 25 36 49 64 81 100 
// 121 144 169 196 225 256 289 324 361 400 
// 1 4 9 16 25 36 49 64 81 100
}
```

Конструктор копирования вызывается только для инициализации. Например, следующие операторы не вызывают конструктор копирования:

```cpp
Array a(10);
Array b(10;

b = a; // Конструктор копирования не вызывается
```

В данном случае оператор `b = а` выполняет присваивание одного объекта другому. Если оператор присваивания не перегружен (как в данном случае), создается побитовая ко­пия объекта, расположенного в его правой части. Следовательно, в некоторых ситуа­циях возникает необходимость не только предусмотреть конструктор копирования, но и перегрузить оператор присваивания.

### 17. Объявление объекта и доступ к его элементам.

/

### 18. Указатели и ссылки на объект.

Чтобы использовать свойства и методы через указатель на объект, необходимо использовать `->` вместо `.`:

```cpp
MyClass o1();
MyClass* o2_ptr = new MyClass();

o1.say_hi();
o1->say_hi();
(*o1).say_hi();
```

### 19. Указатель this.

При вызове функции-члена ей неявно передается указатель на вызывающий объект — указатель `this`.

Сокращенная форма без использования `this` гораздо более практична, однако указатель `this` очень важен при перегрузке операторов, а также в ситуациях, когда функция-член должна использовать указатель на вызывающий объект.

```cpp
class MyClass
{
    int n;
public:
    MyClass(): n(0) {}
    MyClass(int _n): n(_n) {}
    std::ostream& operator<<(std::ostream&);
};

std::ostream& MyClass::operator<<(std::ostream& out)
{
    out << this->n << std::endl;
    return out;
}
```

### 20. Присвоение объектов.

При присвоении объектов если оператор присваивания не перегружен , создается побитовая ко­пия объекта, расположенного в его правой части. Следовательно, в некоторых ситуа­циях возникает необходимость перегрузить оператор присваивания.

### 21. Объекты в качестве возвращаемого значения функции.

Общий код:

```cpp
class myclass {
    int i;
public:
    myclass() { std::cout << "Constructor" << std::endl; }
    void set_i(int n) { i=n; }
    int get_i() { return i; }
    ~myclass() { std::cout << "Destructor" << std::endl; }
};

myclass f() {
    myclass x;
    x.set_i(1);
    return x;
}
```

- Если инициализировать объект результатом вызова функции, возвращающей объект, всё будет работать как ожидается:
    
    ```cpp
    int main()
    {
        myclass o = f();
    
        std::cout << o.get_i() << "\n";
        return 0;
    }
    ```
    
    ![Screen Shot 2022-03-08 at 09.09.20.png](%D0%9E%D0%9E%D0%9F%20dced1/Screen_Shot_2022-03-08_at_09.09.20.png)
    
- Если присваивать объект-результат вызова функции к уже инициализируемому объекту, то возникнет проблема:
    
    ```cpp
    int main()
    {
        myclass o;
    
        o = f();
    
        std::cout << o.get_i() << "\n";
        return 0;
    }
    ```
    
    ![Screen Shot 2022-03-08 at 09.10.56.png](%D0%9E%D0%9E%D0%9F%20dced1/Screen_Shot_2022-03-08_at_09.10.56.png)
    

При возвращении из функции автоматически создается временный объект, в кото­ром хранится возвращаемое значение. Именно этот объект на самом деле возвращает­ся в вызывающий модуль. После возвращения этот объект уничтожается. Это может привести к непредсказуемым последствиям. Например, если деструктор возвращае­мого объекта должен освобождать динамическую память, она будет освобождаться, даже если объект, которому присваивается возвращаемое значение, по-прежнему ссы­лается на нее. Избежать этого можно с помощью перегрузки оператора присваивания и определения конструктора копирования.

### 22. Встраиваемая функция.

*Англ. - **inline function*.**

В языке C++ можно написать короткую функцию, которая не вызывается, а под­ставляется в соответствующее место программы.  Чтобы заменить вызов функции подстановкой, перед ее определением следует указать слово `inline`.

Пример:

```cpp
// компилятор заменит вызов функции подстановкой выражения
inline int max(int a, int b)
{
	return a > b ? a : b;
}
```

Подставляемые функции могут быть членами класса.

```cpp
class MyClass
{
    int a, b;
public:
    void init(int _a, int _b);
    void show() const;
};

inline void MyClass::init(int _a, int _b)
{
    a = _a;
    b = _b;
}

inline void MyClass::show() const
{
    std::cout << a << " " << b << std::endl;
}
```

если функция определена в объявлении класса, она автоматически превращается в подставляемую:

```cpp
class MyClass
{
    int a, b;
public:
    void init(int _a, int _b);
		// подставляемая
    void show() const
		{
				std::cout << a << " " << b << std::endl;
		}
};
```

### 23. Дружественная функция.

Дружественная по отношению к классу функция имеет доступ к приватным и защищённым полям и методам класса.

Обычно дружественные функции используются для перегрузки операторов или имеют вспомогательное назначение — например, вывод.

```cpp
class TwoVals
{
    int a, b;
public:
    TwoVals(int _a, int _b) { a = _a, b = _b; };
		// class B
    friend std::ostream& operator<<(std::ostream& out, const TwoVals& tw);
};

std::ostream& operator<<(std::ostream& out, const TwoVals& tw)
{
    out << tw.a << " | " << tw.b << std::endl;
    return out;
}

int main()
{
    TwoVals tw(5, 10);
    std::cout << tw; // "5 | 10"

    return 0;
}
```

### 24. Дружественный класс.

Класс `B` можно объявить дружественным по отношению к классу `A`. В таком случае в классе `B` можно будет получить доступ к приватным и защищённым свойствам и методам класса `A`.

Пример:

```cpp
// class A
class TwoVals
{
    int a, b;
public:
    TwoVals(int _a, int _b) { a = _a, b = _b; };
		// class B
    friend class Min;
};

// class B
class Min
{
public:
    int min(const TwoVals&) const;
};

int Min::min(const TwoVals& tw) const
{
    return tw.a > tw.b ? tw.a : tw.b;
}

int main()
{

    TwoVals tw(5, 10);
    Min min;
    std::cout << min.min(tw) << std::endl;

    return 0;
}
```

### 25. Операторы `new` и `delete`.

В языке C++ предусмотрены два оператора динамического распределения памяти:
`new` ****и `delete`**.** Эти операторы выделяют и освобождают память в ходе выполнения программы.

Оператор `new` выделяет область памяти и возвращает указатель на ее первую ячей­ку. Оператор `delete` освобождает память, выделенную ранее с помощью оператора
`new`. Общий вид этих операторов таков:

```cpp
// выделение памяти для одиночных значений
int* num = new int(50); // число 50
delete[] num;

// выделение памяти для массивов
int* arr = new int[size];
delete[] arr;

// выделение памяти для объектов
std::vector<int>* v_ptr = new std::vector<int>();
delete[] v_ptr;
```

Оператор `delete` ****следует применять только к результату оператора `new`**.** В против­
ном случае могут возникнуть проблемы, например, крах операционной системы.

Операторы `new` ****и `delete` ****аналогичны функциям `malloc()` и `free()`, но по сравне­нию с ними обладают несколькими преимуществами: не нужно использовать `sizeof()` и приводить тип возвращаемого указателя; *операторы `new` и `delete` можно перегружать.*

### 26. Защищенные члены класса.

/

### 27. Множественное наследование.

```cpp
class base2
{
protected:
    int y;
public:
    void showy() { std::cout << y << std::endl; }
};

class derived : protected base1, protected base2
{
public:
    void show_all()
    {
        showx();
        showy();
    }
};
```

### 28. Виртуальные базовые классы.

При множественном наследовании может возникнуть неоднозначность. Рассмот­рим, например, следующую неправильную программу. — `Derived3` является наследников `Derived1` и `Derived2`.

```cpp
#include <iostream>

class Base
{
public:
    Base(): i(0)
    {
        std::cout << "Base" << std::endl;
    }
    int i;
};

class Derived1 : public Base
{
public:
    int j;
};

class Derived2 : public Base
{
public:
    int k;
};

class Derived3 : public Derived1, public Derived2
{
public:
    int sum;
};

int main()
{
    // x2 "Base"
    Derived3 d3;
	
    // ошибка: неявное имя переменной
    d3.i = 20;

    return 0;
}
```

![Untitled](%D0%9E%D0%9E%D0%9F%20dced1/Untitled%203.png)

Программу можно исправить двумя способами:

1. К переменной `i` применить оператор разрешения области видимости:

```cpp
int main()
{
    // все еще два вывода "Base"
    Derived3 d3;
	
		// неодназначность устранена
		d3.Derived1::i = 20;
    d3.j = 30;
    d3.k = 40;

    d3.sum = d3.Derived1::i + d3.j + d3.k;
    
    std::cout << d3.sum << std::endl;

    return 0;
}
```

Оператор разрешения области видимости `::` позволяет явно выбрать вариант производного класса. Однако это решение порождает новые проблемы Что
если на самом деле нужна лишь одна копия объекта класса **base?** Можно ли предот­вратить дублирование объектов класса **base** в объекте класса **derived3?**

Да, можно, если применять virtual base classes.

1. Если базовый класс имеет несколько наследников, его дублирование можно пре­дотвратить. Для этого в объявлении производного класса перед именем базового клас­са следует поставить ключевое слово `virtual`**.**
    
    ```cpp
    #include <iostream>
    
    class Base
    {
    public:
        Base(): i(0)
        {
            std::cout << "Base" << std::endl;
        }
        int i;
    };
    
    class Derived1 : virtual public Base
    {
    public:
        int j;
    };
    
    class Derived2 : virtual public Base
    {
    public:
        int k;
    };
    
    class Derived3 : public Derived1, public Derived2
    {
    public:
        int sum;
    };
    
    int main()
    {
        // один вывод "Base"
        Derived3 d3;
    	
        // неодназначность устранена
        d3.i = 20;
    
        return 0;
    }
    ```
    

Как видим, перед именем базового класса в спецификации производного класса стоит ключевое слово `virtual`. Теперь оба класса `Derived1` и `Derived2` являются наследниками виртуального базового класса base, и любые их наследники будут со­ держать лишь одну копию класса `Base`. Следовательно, объект класса `Derived3` со­ держит копию объекта класса `Base`, и выражение `d3.i= 10` становится совершенно правильным и однозначным.

---

Следует иметь в виду, что, хотя классы `Derived1` и `Derived2` объявили класс `Base` *виртуальным*, его объекты будут по-прежнему частью объектов любого из этих типов. Например, следующий фрагмент является совершенно правильным:

```cpp
void print_i(const Base& b)
{
    std::cout << b.i << std::endl;
}

Derived3 d3;
d3.i = 16;
Derived1 d1;
d1.i = 74;
Base b;

print_i(d3);
print_i(d1);
print_i(b);
```

---

Различие между обычным базовым классом и виртуальным проявляется только когда объект наследует несколько объектов одного и того же базового класса. Если используется виртуальный базовый класс, то его объект только один раз копируется в каждый объект производного класса. В противном случае возникает неоднозначность.

### 29. Указатель на объект производного класса.

Как правило, указатель одного типа не может ссылаться на объект другого типа. Однако у этого правила есть важное исключение, касающееся производных классов.

Если класс `B` является производным от класса `A`, то указатель типа `A*` может ссылаться на объекты типа `B`:

```cpp
class A
{
	int n;
public:
	A(): n(10) {};
	void print_n() const { std::cout << n << std::endl; }
};

class B: public A
{
    int m;
public:
    B(): m(20) {};
    void print_m() const { std::cout << m << std::endl; }
};

int main()
{
    A* a_ptr;
    B b;

    // базовый указатель ссылается на объект производного класса
    a_ptr = &b;

    a_ptr->print_n(); // 10

    /* нельзя
    a_ptr->print_m(); */

	return 0;
}
```

Указатель на базовый класс можно привести к ти­пу указателя на производный класс:

```cpp
int main()
{
    A* a_ptr;
    B b;

    a_ptr = &b;

    ((B*)a_ptr)->print_m();

	return 0;
}
```

Следует помнить, что адресная арифметика зависит от типа базового указателя По этой причине, если указатель на объекты базового класса используется для доступа к производным объектам, увеличение указателей не откроет доступ к следующему объекту производного типа. Вместо этого он будет ссылаться на объект базового типа. Разумеется, это может вызвать недоразумения. Рассмотрим программу, которая, буду­чи совершенно правильной с синтаксической точки зрения, является ошибочной.

```cpp
class base
{
    int i;
public:
    void set_i(int num) { i=num; }
    int get_i() { return i; }
};

class derived: public base
{
    int j;
public:
    void set_j(int num) { j=num; }
    int get_j() { return j; }
};

int main()
{
    base *bp;
    derived d[2];
    bp = d;
    
    d[0].set_i(1);
    d[1].set_i(2);

    std::cout << bp->get_i() << " ";
    bp++; // Этот оператор относится к базовому,
          // а не производному типу
    std::cout << bp->get_i(); // На экран выводится мусор.
return 0;
}
```

### 30. Виртуальные методы. Наследование виртуальных методов.

*Виртуальная функция* — функция-член, объявленная в базовом классе и переопределенная в производном.

Чтобы создать виртуальную функ­цию, следует указать ключевое слово `virtual` ****перед ее объявлением в базовом классе. Производный класс переопределяет эту функцию, приспосабливая ее для своих нужд.

По существу, виртуальная функция реализует принцип “один интер­фейс, несколько методов”, лежащий в основе полиморфизма. Виртуальная функция в базовом классе определяет *вид интерфейса*, т.е. способ вызова этой функции. Ка­ждое переопределение виртуальной функции в производном классе реализует опе­рации, присущие лишь данному классу. Иначе говоря, переопределение виртуаль­ной функции создает *конкретный метод*.

**Атрибут `virtual` наследуется.**

При наследовании виртуальной функции ее виртуальная природа также наследует­ся. Это значит, что если производный класс, унаследовавший виртуальную функцию от базового класса, становится базовым по отношению к другому производному классу, виртуальная функция может по-прежнему замещаться. Иначе говоря, не имеет значения, сколько раз наследовалась виртуальная функция, она все равно остается виртуальной.

**Виртуальные функции являются иерархическими.**

Как известно, если функция объявлена виртуальной в базовом классе, ее можно за­местить в производном классе. Однако виртуальную функцию не обязательно замещать. В этом случае вызывается функция, определенная в базовом классе.

### 31. Чисто виртуальные функции и абстрактные классы.

Итак, если виртуальная функция не замещается в производном классе, вызывается ее версия из базового класса. Однако во многих случаях невозможно создать разум­ную версию виртуальной функции в базовом классе. Например, базовый класс может не обладать достаточным объемом информации для создания виртуальной функции. Кроме того, в некоторых ситуациях необходимо гарантировать, что виртуальная функция будет замещена во всех производных классах. Для этих ситуаций в языке C++ предусмотрены чисто виртуальные функции.

*Чисто виртуальная функция* (pure virtual function) — это виртуальная функция, не
имеющая определения в базовом классе.

**Чисто виртуальные функции должны переопределяться в каждом производном классе, в противном случае возникнет ошибка компиляции.**

Синтаксис: `virtual void make_sound() const = 0;`

- Пример
    
    ```cpp
    class Animal
    {
        std::string species;
    public:
        Animal(std::string);
        Animal(const char*);
        virtual void make_sound() const = 0;
        ~Animal();
    };
    
    class Wolf : public Animal
    {
    public:
        Wolf();
        void make_sound() const;
    };
    
    Animal::Animal(std::string _species): species(_species) {}
    
    Animal::Animal (const char* _species): species(_species) {}
    
    void Animal::make_sound() const
    {
        std::cout << "Moo?.." << std::endl;
    }
    
    Animal::~Animal() {}
    
    Wolf::Wolf(): Animal("wolf") {}
    
    void Wolf::make_sound() const
    {
        std::cout << "Woof! Woof!" << std::endl;
    }
    
    void trigger_make_sound(const Animal& animal)
    {
        animal.make_sound();
    }
    ```
    

**Абстрактные классы**

Класс, содержащий хотя бы одну чисто виртуальную функцию, называется *абст­рактным* (abstract class). Поскольку абстрактный класс содержит одну или несколько
функций, не имеющих определения (т.е. чисто виртуальные функции), **его объекты
создать невозможно**. Следовательно, абстрактные классы можно использовать лишь как основу для производных классов.

Несмотря на то что объекты абстрактного класса не существуют, можно создать
указатели и ссылки на абстрактный класс. Это позволяет применять абстрактные классы для поддержки динамического полиморфизма и выбирать соответствующую виртуальную функцию в зависимости от типа указателя или ссылки.

### 32. Перегрузка функций.

*Перегрузка функций* — это использование одного имени для нескольких функций.

При перегрузке каждое переопределение функции должно использовать либо другие типы параметров, либо другое их количество.

**Конструкторы можно перегружать.**

### 33. Перегрузка унарных операторов.

```cpp
class Vec
{
    double x, y;
public:
    Vec(): x(0), y(0) {}
    Vec(int _x, int _y): x(_x), y(_y) {}
    double get_x() const { return x; }
    double get_y() const { return y; }
    Vec& operator++()
    {
        x += 1;
        y += 1;

        return *this;
    }
    Vec& operator++(int)
    {
        x += 1;
        y += 1;

        return *this;
    }
};
```

постфиксный и префиксный инкременты перегружены одинаково.

`operator++(int)` - `int` здесь - затычка, чтобы отличить постфикс от префикса.

### 34. Перегрузка бинарных операторов.

```cpp
Vec operator+(const Vec& v2) const
{
    return Vec(x + v2.x, y + v2.y);
}
Vec operator+=(const Vec& v2)
{
    x += v2.x;
    y += v2.y;

    return *this;
}

Vec vec1(11, 12);
Vec vec2(5, -9);

Vec vec3 = vec1 + vec2;
```

### 35. Перегрузка оператора индексации массивов `[]`

```cpp
class Array
{
    int* arr;
    size_t size;
public:
    Array(size_t n);
    Array(const Array&);
    int& operator[](size_t);
    void operator()();
    ~Array();
};

Array::Array(size_t n): size(n)
{
    arr = new int[size];
}

Array::Array(const Array& arr2)
{
    arr = new int[arr2.size];

    for (size_t i = 0; i < arr2.size; i++)
        arr[i] = arr2.arr[i];
}

Array::~Array()
{
    delete[] arr;
}

int& Array::operator[](size_t pos)
{
    return arr[pos];
}
```

### 36. Аргументы, передаваемые функции по умолчанию.

```cpp
void print_labeled_arr(
	const int* arr,
	const size_t size,
	const char* msg = "Hello, World!")
{
	std::cout << msg << std::endl;

	for (size_t i = 0; i < size; i++)
		std::cout << arr[i] << " ";
}
```

### 37. Определение адреса перегруженной функции.

Функция имеет адрес. Этот адрес можно присвоить указателю, а затем вызывать функцию не по имени, а через ее указатель.

Если функция `myfunc()` не перегружена, она существует в одном экземпляре, и компи­лятор без труда вычисляет ее адрес. Однако, если функция `myfunc()` перегружена, воз­никает вопрос, каким образом компилятор может вычислить ее указатель? Ответ зави­сит от того, как объявлен указатель `р`.

```cpp
int myfunc(int);
int myfunc(int, int);

int main()
{
    int (*fp)(int, int);
    
    fp = myfunc;

    std::cout << fp(5, 3) << std::endl; // 15

    return 0;
}

int myfunc(int a)
{
    return a;
}

int myfunc(int a, int b)
{
    return a * b;
}
```

### 38. Класс `vector`.

`std::vector<T>` — динамический массив.

- `begin`, `end`, `rbegin`, `rend
cbegin`, `cend`, `crbegin`, `crend`
- `push_back`, `pop_back`
- `at(size_t i)` — возвращает ссылку на i-ый элемент
- `back` — возвращает ссылку на последний элемент
- `size_t capacity() const` — возвращает число элементов, которое вектор может содержать без выделения дополнительного пространства.
- `size()` — Возвращает количество элементов в векторе.
- `clear()`
- `empty()`
- `erase()` — Удаляет элемент или диапазон элементов в векторе из заданных позиций.
итератор или итераторы  begin-end `[it_beg; it_end)`
- `insert()` — вставляет элемент или несколько элементов или диапазон элементов в указанную позиции в вектор.

### 39. [Класс](https://docs.microsoft.com/ru-ru/cpp/standard-library/basic-string-class?view=msvc-170#append) `[string](https://docs.microsoft.com/ru-ru/cpp/standard-library/basic-string-class?view=msvc-170#append)`.

- `size()`/`length()`
- `c_str()` — возвращает строку, преобразованную в C-строку
- `starts_with()`/`ends_with()`
- `std::string substr(size_t offset = 0, size_t count = npos)` — Копирует из указанного положения в строке подстроку, содержащую по крайней мере несколько символов
    
    ```cpp
    std::string s = "Hello, World!123 12 3123 123 123 3 123123 123";
        std::cout << s.substr(0, 13) << std::endl; // Hello, World!
    ```
    
- `find`/`rfind`
    
    ```cpp
    std::string s = "Hello, World!123 12 3123 123 123 3 123123 123";
    
    size_t pos = s.find("World");
    size_t pos_end = s.find_last_of("World");
    
    std::cout << pos << " "  << pos_end << std::endl; // 7 11
    ```
    
- `copy(char* c, size_t n, size_t offset = 0) const` — копирует часть строки в `c`
- `replace()` — заменяет элементы в строке в указанной позиции заданными символами или символами, скопированными из других диапазонов, строк или C-строк.
- `append()` - добавляет символы в конец строки
- `erase()` - удаляет элемент или диапазон элементов с указанного положения в строке

```cpp
iterator erase(
    iterator first,
    iterator last);

iterator erase(
    iterator iter);

basic_string<CharType, Traits, Allocator>& erase(
    size_type offset = 0,
    size_type count = npos);
```

- `find_last_of` — Выполняет в строке поиск последнего символа, совпадающего с любым элементом заданной строки.
- `capacity()`
- `static const size_type npos = -1` — целочисленное значение без знака, инициализированное значением -1, которое указывает на отсутствие найденных или всех оставшихся символов при сбое функции поиска.

### 40. Класс `map` и `multimap`.

`std::map<K, V>` — ассоциативный массив, хранящий значения типа `V` по ключам типа `K`.

- те же методы, что и у `multimap`

`std::multimap<K, V>` — *мультиотображение* — множество, в которое каждый элемент может входить несколько раз

```cpp
#include <map>
#define int_pair std::pair<int, int>

template <typename K, typename V>
void show(const std::multimap<K, V>& mm)
{
    for (typename std::multimap<K, V>::const_iterator it = mm.begin(); it != mm.end(); it++)
        std::cout << it->first << " " << it->second << std::endl;
}
```

- `multimap::begin()`, `multimap::end()` — возвращает итератор, адресующий первый элемент в мультиотображении.
- `rbegin`, `rend`
- `multimap::cbegin()`, `multimap::cend()` — возвращает константный итератор, адресующий первый элемент в мультиотображении.
- `crbegin`, `crend`
- `multimap::insert(std::pair)` — вставляет в мультиотображение пару ключ-значение, представляемую парой `std::pair<K, V>`.
- `multimap::count(const K&)` — возвращает число элементов в мультиотображении, ключи которых совпадают с ключом, заданным параметром.
- `bool multimap::contains(const &K)` — проверяет, существует ли элемент с указанным ключом в `multimap`
- `multimap::empty()` — проверяет, что мультиотображение пусто — возвращает **`true`**, если `multimap` пусто; **`false` е**сли `multimap` не является пустым.
- `multimap::clear()` — удаляет все элементы мультиотображения
- `multimap::size()` — возвращает размер мультиотображения
- `multimap::find(const K&)` — возвращает итератор, ссылающийся на элемент в мультикарте, ключ которого эквивалентен заданному ключу.
- `multimap::erase(const_iterator Where)`/`multimap::erase(const_iterator First, const_iterator Second)`/`multimap::erase(const K&)`
- `multimap::equal_range` — Находит диапазон элементов, где ключ элемента соответствует заданному значению.

```cpp
pair<const_iterator, const_iterator> equal_range (const Key& key) const;

pair<iterator, iterator> equal_range (const Key& key);
```

### 41. Объявление элементов класса спецификацией `static`.

Члены класса могут быть статическими.

Независимо от количества объектов класса, статическая переменная всегда существует в одном экземпляре.

Объявление статической переменной-члена в классе не означает ее *определения*
(иначе говоря, память для нее не выделяется). Чтобы разместить статическую переменную в памяти, следует определить ее вне класса, т.е. глобально. (строка `int Shared::n = 0` необходима)

```cpp
class Shared
{
    static int n;
    int b;
public:
    void increment() const;
    static void show();
};

int Shared::n; // int Shared::n = 0;
void Shared::increment() const
{
    Shared::n++;
}
void Shared::show()
{
    std::cout << Shared::n << std::endl;
}

int main()
{
    Shared o;
    Shared::show();
    o.increment();
    Shared::show();

    return 0;
}
```

```cpp
class Counter
{
public:
    static int count;
    Counter() { count++; }
    ~Counter() { count--; }
};

int Counter::count = 0;
```

### 42. Объявление элементов класса спецификацией `const`.

Если объявить поле класса со спецификацией `const`, при создании каждого нового объекта будет выделяться память для хранения значения переменной, которая представляет это поле класса.

Если объявить статическое поле класса со спецификацией `const`, при определении (определять нужно явно) поля память для хранения значения выделится единожды, далее значение нельзя будет изменить.

```cpp
class Counter
{
public:
    static const int count;
};

const int Counter::count = 15;
```

Если объявить метод-член класса со спецификацией `const`, в методе нельзя будет изменить значения полей класса или вызвать методы, делающие это:

```cpp
class Counter
{
    int count;
public:
    Counter(int n = 0): count(n) {}
    int increment() { return ++count; }
    void show() const { std::cout << count << std::endl; }
    ~Counter() {}
};
```

### 43. Шаблон функции.

Шаблон функции (обобщенная функция) позволяет определять функцию для многих типов данных.

```cpp
template <typename T>
void print_arg(T arg)
{
	std::cout << arg << std::endl;
}
```

Явная перегрузка шаблонной функции

```cpp

void print_arg(double arg)
{
	std::cout << "Printing 'double' type value": arg << std::endl;
}
```

---

Ограничения на обобщенные функции

Обобщенные функции напоминают перегруженные, но на них налагаются еще бо­лее жесткие ограничения. При перегрузке внутри тела каждой функции можно вы­полнять разные операции. В то же время обобщенная функция должна выполнять од­ну и ту же универсальную операцию для всех версий, различаться могут лишь типы данных.

### 44. Шаблон класса.

Шаблон класса (обобщенный класс) позволяет определять класс для многих типов данных.

Обобщенный класс — класс, в котором определены все алгоритмы, однако фактический тип дан­ных задается в качестве параметра при создании объекта. Обобщенные классы оказываются полезными, если логика класса не зависит от типа данных.

```cpp
template <typename T>
class Stack
{
    T* stack;
    size_t size;
public:
    Stack(size_t _size);
    bool pop(T& into);
    bool push(const T& val);
    size_t max_size() const;
    size_t cur_size() const;
};

template <typename T>
Stack<T>::Stack(size_t _size): size(_size) {}
```

**Применение стандартных типов в обобщенных классах**

```cpp
template <typename T, int size>
class Stack
{
    T stack[size];
    size_t max_size;
public:
    Stack();
    bool pop(T& into);
    bool push(const T& val);
    size_t get_max_size() const;
    size_t get_cur_size() const;
};

template <typename T, int size>
Stack<T, size>::Stack()
{
    max_size = size;
}
```

**Применение аргументов по умолчанию в шаблонных классах**

```cpp
template <typename T = int>
class myclass { /* ... */ }
```

**Явная специализация класса**

```cpp
template <typename T> class myclass {}

// Явная специализация класса
template <> class myclass<int> {} 
```

### 45. Контейнеры и итераторы.

Основные контейнеры:

- `std::vector`
- `std::list`
- `std::set`
- `std::map`
- `std::queue`

Итераторы STL-контейнеров:

- `begin`, `end`, `rbegin`, `rend`
- `cbegin`, `cend`, `crbegin`, `crend`

### 46. Контейнер – динамический массив.

Это есть `std::vector`

### 47. Контейнер – ассоциативный список.

Есть `std::map`

### 48. Исключительные ситуации.

Оператор `throw` позволяет сгенерировать исключительную ситуацию.

```cpp
struct MyException
{
	MyException(const char* message): _message(message) {}
	const char* what() const
	{
		return _message;
	}
private:
	const char* _message;
};

int main()
{
    try {
        throw MyException("foobar");
    } catch (const MyException& e)
    {
       std::cout << "Caught custom exception!" << std::endl
        << e.what() << std::endl; 
    }
    return 0;
}
```

Если в программе предусмотрен ее перехват, оператор `throw` должен выполняться либо внутри блока `try` , либо внутри функции, явно или неявно вызываемой внутри блока `try`.

Синтаксис `try`/`catch`

```cpp
try {
	// ...
}
catch (const typeone& arg) {
	// ...
}
catch (const typetwo& arg) {
	// ...
}
// ...
catch (const typeN& arg) {
	// ...
}
```

**блок обрабатывает все ошибки** (можно добавлять после блоков `catch`, обрабатывающих какие-либо типы аргументов:

```cpp
try {
	// ...
}
catch (...) {
	// ... handles any errors or unhandled errors
}
```

> ❗ Оператор `catch`, соответствующий базовому классу, одновременно соответствует и всем производным классам.
> 

---

**Ограничение исключительных ситуаций**

Можно ограничить типы исключительных ситуаций, которые может генерировать функция:

```cpp
template <typename T>
class MyArray
{
    T* arr;
		size_t capacity = 5;
    size_t cur_size = 2;
public:
    T& operator[](size_t pos) const throw(IndexOutOfRangeException);
};

template <typename T>
T& MyArray<T>::operator[](size_t pos) const throw(IndexOutOfRangeException) {
	if (pos >= cur_size)
		throw IndexOutOfRangeException("");
  throw "";
	return arr[pos];
}
```

Если запросить элемент, находящийся по индексу, не существующему в массиве, возникнет ошибка, перехватив которую продолжится выполнение программы.

Если же этой ошибки не возникнет, перегруженный оператор `[]` сгенерирует *неожиданное* исключение типа `const char*`, из-за которого, вне зависимости от обработки исключений, программа аварийно завершится ( на самом деле попытка сгенерировать исключительную ситуацию, не поддерживаемую функ­цией, сопровождается вызовом стандартной функции `unexpected()`. Затем по умолчанию вызывается функция `abort()`, и программа завершается аварийно.).

Если необходимо запретить функции вообще генерировать *любые* исключительные си­туации, список типов следует оставить пустым:

```cpp
template<typename T>
void MyArray<T>::print_array() const throw()
{
	for (size_t i = 0; size_t < capacity; i++)
	{
		if (i)
			std::cout << " ";
		std::cout << arr[i];
	}
	std::cout << std::endl;
}
```

### 49. Приведение типов.

 В C++ для поддержки объектно-ориентированного программирования используется динамическая идентификация типа (RTTI - Run-Time Type Identification).

Оператор `typeid` возвращает ссылку на объект типа `type_info`, у которого определены операции `==`, `!=`, а также у которого есть метод `name`, возвращающий указатель `const char*` на имя объекта.

---

В языке C++ существуют пять операторов приведения типов. Первый оператор является вполне традиционным и унаследован от языка С. Остальные четыре были добавлены впоследствии. К ним относятся операторы `dynamic_cast`, `const_cast`, `reinterpret_cast` и `static_cast`. Эти операторы позволяют полнее контролиро­вать процессы приведения типов.

---

**Стандартное приведение типов**:

```cpp
void* arr = (float*)(malloc(size * sizeof(float)));
```

**`dynamic_cast`**

Осуществляет динамическое приведение типа с последующей про­веркой корректности приведения. Если приведение оказалось некорректным, оно не выполняется.

Результирующий тип должен быть указательным или ссылочным, а приводимое выражение - вычислять указатель или ссылку.

```cpp
dynamic_cast<target_type>(expression);
```

Оператор `dynamic_cast` ****предназначен для приведения полиморфных типов.

До­пустим, даны два полиморфных класса `B` и `D`, причем класс `D` является производным
от класса `B`. Тогда оператор `dynamic_cast` может привести указатель типа `D*` к ти­пу `B*`. Это возможно благодаря тому, что указатель на объект базового класса может ссылаться на объект производного класса. Однако обратное динамическое приведе­ние указателя типа `D*` к типу `B*` возможно лишь в том случае, если указатель дейст­вительно ссылается на объект класса `D`. Оператор `dynamic_cast` достигает цели, ес­ли указатель или ссылка, подлежавшие приведению, ссылаются на объект резуль­тирующего класса или объект класса, производного от результирующего. В противном случае приведение типов считается неудавшимся. В случае неудачи оператор `dynamic_cast`, примененный к указателям, возвращает нулевой указатель. Если оператор `dynamic_cast` применяется к ссылкам, в случае ошибки генерирует­ся исключительная ситуация `bad_cast`.

Примеры приведения типов:

```cpp
class Base {
public:
    virtual void f() { std::cout << "Hello, World!\n"; }
};
class Derived: public Base {
public:
    void f() { std::cout << "Hello from Derived\n"; }
};

int main()
{
    Base b, *bp;
    Derived d, *dp;

    dp = dynamic_cast<Derived*>(&d); // то же, что и dp = &d

    bp = dynamic_cast<Base*>(&d); // bp = &d

    dp = dynamic_cast<Derived*>(bp);

    if (dp) std::cout << "Конвертация успешна" << std::endl;

    // указатель теперь ссылается на тип Base
    dp = dynamic_cast<Derived*>(&b);

    // 
    if (dp == nullptr) std::cout << "Конвертация неудачна" << std::endl;

    bp = &b;
}
```

`**const_cast**`

Оператор `const_cast` используется для явного замещения модификаторов `const` и/или `volatile`.

```cpp
void sqrval(const int* val)
{
    int *p = const_cast<int*>(val);

    *p = *val * *val;
}

int main()
{
    int num = 10;

    std::cout << num << std::endl; // 10

    sqrval(&num);

    std::cout << num << std::endl; // 100

    return 0;
}
```

`**reinterpret_cast**`

Оператор преобразует один тип в совершенно другой.

Например, указатель в `long`

```cpp
char num = 'B';
char* p_num = &num;

std::cout << reinterpret_cast<long>(p_num) << std::endl;
```

**`static_cast`**

Оператор заменяет обычное приведение:

```cpp
int main()
{
	for (int i = 0; i < 10; i++)
		std::cout << static_cast<double>(i) / 3 << " ";

	return 0;
}
```

### 50. Сигналы и обработчики.

[Подробнее](https://unetway.com/tutorial/c-obrabotka-signalov)

Сигналы - это прерывания, передаваемые процессу операционной системой, которые могут прервать программу преждевременно.

Есть сигналы, которые не могут быть пойманы программой, но есть следующий список сигналов, которые вы можете поймать в своей программе и можете принимать соответствующие действия на основе сигнала. Эти сигналы определены в файле заголовка C++ `<csignal>`.

- `SIGABRT` — Аномальное завершение программы, например, вызов **прерывания** .
- `SIGFPE` — Ошибочная арифметическая операция, такая как деление на ноль или операция, приводящая к переполнению.
- `SIGILL` — Обнаружение незаконной инструкции.
- `SIGINT` — Получение сигнала интерактивного внимания.
- `SIGSEGV` —Недействительный доступ к хранилищу.
- `SIGTERM` — Запрос завершения, отправленный в программу.

Библиотека управления сигналами `<csignal>` предоставляет `signal()` для обнаружения неожиданных событий:

```cpp
void (*signal (int sig, void (*func)(int)))(int);
```

```cpp
#include <iostream>
#include <csignal>
#include <unistd.h>

using namespace std;

void signalHandler(int signum)
{
    cout << "Interrupt signal (" << signum << ") received.\n";

    // cleanup and close up stuff here
    // terminate program

    exit(signum);
}

int main()
{
    // register signal SIGINT and signal handler
    signal(SIGINT, signalHandler);

    while (1)
    {
        cout << "Going to sleep...." << endl;
        sleep(1);
    }

    return 0;
}
```

---

Функция `raise` позволяет генерировать сигналы прерывания:

```cpp
#include <iostream>
#include <csignal>
#include <unistd.h>

using namespace std;

void signalHandler(int signum)
{
    cout << "Interrupt signal (" << signum << ") received.\n";

    // cleanup and close up stuff here
    // terminate program

    exit(signum);
}

int main()
{
    int i = 0;
    // register signal SIGINT and signal handler
    signal(SIGINT, signalHandler);

    while (++i)
    {
        cout << "Going to sleep...." << endl;
        if (i == 3)
        {
            raise(SIGINT);
        }
        sleep(1);
    }

    return 0;
}
```

### 51. Ввод-вывод в С++. Потоки.

Текстовый поток — это последовательность символов, к которым можно получить доступ. Со временем поток может производить или потреблять потенциально неограниченные объемы данных.

В C++ для ввода и вывода используются потоки `cin` и `cout`.

### 52. Форматированный ввод-вывод данных.

Функции `printf()` и `scanf()` выполняют форматированный ввод-вывод на кон­соль, иначе говоря, они могут считывать и записывать данные в заданном формате.

Также для форматирования можно использовать библиотеку `<iomanip>`.
В ней есть такие манипуляторы потока вывода как `setw()`, `right`, `left` и др.